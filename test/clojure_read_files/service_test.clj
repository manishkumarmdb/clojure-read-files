(ns clojure-read-files.service-test
  (:require [clojure.test :refer :all]
            [io.pedestal.test :refer :all]
            [io.pedestal.http :as bootstrap]
            [clojure-read-files.service :as service]))

(def service
  (::bootstrap/service-fn (bootstrap/create-servlet service/service)))

(deftest home-page-test
  (is (=
       (:body (response-for service :get "/"))
       "<html><head><title>Read files in clojure</title></head><body><div><div><h4>Question. </h4><p> Write a program that reads 05 essays from plain-text files,\n  then prints those essays as a table of 05 columns. Each essay should be printed\n  in its own column. The essay should be printed as justified text with word wrap,\n  without any loss of formatting (newline) around paragraphs.</p></div><div><h4>Answer.</h4></div><div><html><head><link href=\"/css/style.css\" media=\"screen\" rel=\"stylesheet\" /></head><body><div><table class=\"table-table\"><thead><tr><th class=\"table-th\">essay_01</th><th class=\"table-th\">essay_02</th><th class=\"table-th\">essay_03</th><th class=\"table-th\">essay_04</th><th class=\"table-th\">essay_05</th></tr></thead><tbody><tr><td class=\"table-td\"><div class=\"table-td-div\"><p>Guide Assumptions</p><p></p><p>Like Hello World, this guide is for beginners who are new to Pedestal and may be new to Clojure. It doesn’t assume any prior experience with a Clojure-based web framework. You should be familiar with the basics of HTTP: URLs, response codes, and content types.</p><p></p><p>If you’ve already done some of those other things, you might want to skip ahead to Your First API to start building some logic and multiple routes.</p><p></p><p>If you like to jump straight in to the deep end, you might be interested in the Pedestal Crash Course which assumes you know quite a bit about Clojure and web frameworks.</p><p></p><p>This guide also assumes that you are in a Unix-like development environment, with Java installed. We’ve tested it on Mac OS X and Linux (any flavor) with great results. We haven’t yet tried it on the Windows Subsystem for Linux, but would love to hear from you if you’ve succeeded with it there.</p></div></td><td class=\"table-td\"><div class=\"table-td-div\"><p>A route may specify constraints on path parameters and query string parameters. Constraints are tested when a request is being matched against a route. If the request does not satisfy a route's constraints, it is not considered a match.</p><p></p><p>Constraints are specified as a map marked with ^:constraints metadata. The keys in the map are path parameters or query string parameters. The values are regular expressions used for testing parameter values.</p></div></td><td class=\"table-td\"><div class=\"table-td-div\"><p>Once a route table is defined, it can be used to create a router. The io.pedestal.http.route/router function takes a route table as input and returns an interceptor that handles routing.</p><p></p><p>(defn hello-world [req] {:status 200 :body \"Hello World!\"})</p><p></p><p>(defroutes master-routes</p><p>    [[[\"/hello-world\" {:get hello-world}]]])</p><p></p><p>(def router (router master-routes))</p><p></p><p>When a routing interceptor's enter function is invoked, it attempts to match the incoming request against each route in the route table in turn. If a route matches, the routing interceptor adds all the interceptors for the given route to the current interceptor path. They will be invoked by the interceptor engine after the router's function completes. It also adds the selected route to the interceptor context map so that other interceptors can know which route was selected.</p><p></p><p>If no route matches, the router simply returns the current interceptor context without modification.</p><p></p><p>During development it is useful to be able to reprocess route definitions without restarting your server. If you call the router function and pass a function that returns a route table, it will be called every time the routing interceptor is used. This allows your Web server to use the latest compiled routes without restarting.</p><p></p><p>(def router (router #(deref #'master-routes)))</p><p></p><p>If you are using the Pedestal service template for lein, it provides a default route table and handles setting up a routing interceptor as one of the steps of building a service. It also configures use of the latest compiled routes when running in the repl.</p></div></td><td class=\"table-td\"><div class=\"table-td-div\"><p>Route names</p><p></p><p>Every route has a name, represented as a keyword. Route names are implicit, where possible. For routes that specify destination interceptors using symbols, the name is the fully-qualified symbol name expressed as a keyword.</p><p></p><p>For routes that specify destination interceptors directly as interceptor values, the route-name is the name of the interceptor.</p><p></p><p>For interceptors defined using the defbefore, defafter, defaround, defon-request, defhandler and defon-response macros in the io.pedestal.interceptor namespace, the name is the interceptor's fully-qualified symbol name expressed as a keyword.</p><p></p><p>For interceptors defined using the before, after, around, on-request, handler and on-response functions in the io.pedestal.interceptor namespace, the name is the keyword passed to the function, if any.</p><p></p><p>For routes that specify interceptors indirectly as lists to be evaluated, no route name can be implicitly assigned.</p><p></p><p>You can specify an explicit route name for any route by adding a keyword as the first item in the vector specified as the value of a given HTTP verb for a given route. Explicit route names take precedence over implicit names. For routes that cannot be given an implicit name, an explicit name must be provided or an exception will be thrown during route expansion.</p></div></td><td class=\"table-td\"><div class=\"table-td-div\"><p>Verb maps</p><p></p><p>In most cases, a nested vector specifying routes contains a path and a verb map (there are exceptions, explained below). The verb map contains keys corresponding to HTTP verbs. All verbs are supported, along with the special value :any, indicating a match to any HTTP verb. Each verb represents a different route. The values in the verb map represent the \"destination interceptor\". Additional intermediate interceptors may also be invoked, as described below.</p></div></td></tr></tbody></table></div></body></html></div></div></body></html>"))
  (is (=
       (:headers (response-for service :get "/"))
       {"Content-Security-Policy"           "object-src 'none'; script-src 'unsafe-inline' 'unsafe-eval' 'strict-dynamic' https: http:;",
        "Content-Type"                      "text/html",
        "Strict-Transport-Security"         "max-age=31536000; includeSubdomains",
        "X-Content-Type-Options"            "nosniff",
        "X-Download-Options"                "noopen",
        "X-Frame-Options"                   "DENY",
        "X-Permitted-Cross-Domain-Policies" "none",
        "X-XSS-Protection"                  "1; mode=block"}
       )))



